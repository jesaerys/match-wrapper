"""

====================
`match_wrapper.util`
====================

"""
class Param(object):

    """Class that bundles a format string with a value.

    Attaching a format string to a value eliminates the need for
    independently keeping track of the value's intended format. Also, a
    formatted string for a `Param` instance is generated by any function
    that uses the `__str__` method, such as `print` or `str()`.

    Parameters
    ----------
    val : None, bool, str, int, float, list, or tuple
        Initialize the `val` property.
    fmt : str, optional
        Initialize the `fmt` property. Default is None (or None for each
        value in `val`). If `val` is multivalued and `fmt` is not, then
        automatically apply `fmt` to each value.
    delim : str, optional
        Initialize the `delim` attribute. Default is a single comma without
        spaces, ",".

    Attributes
    ----------
    delim : str
        The delimiter to use when formatting `val` as a string if `val` is
        list-like.

    Methods
    -------
    val
        Property (get and set). The value or set of values.
    fmt
        Property (get and set). Format string for the `val` property. If
        `val` is a list, then `fmt` is a list with a format string for each
        value in `val` (this is checked whenever `val` is updated; `fmt`
        will automatically be expanded to a list of the correct length if
        `val` is updated with a single format string). `fmt` should either
        use an index of 0 or no index at all (e.g., '{0:d}' or '{:d}').

    Examples
    --------
    There are several ways to initialize `Param`. For example,

    >>> def print_param(p):
    ...    print p.val, p.fmt, p

    Single value, no format:

    >>> p = Param(0)
    >>> x = 3.14159
    >>> p.val = x  # `.val` can be updated whenever
    >>> print_param(p)
    3.14159 None 3.14159
    >>> p.fmt = '{:.2f}'  # now assign a format
    >>> print_param(p)
    3.14159 {:.2f} 3.14

    The last result can also be achieved by specifying a format right at
    initialization, either with the `fmt` keyword or by pairing the value
    with the format string in a tuple:

    >>> str(p) == str(Param(x, fmt='{:.2f}')) == str(Param((x, '{:.2f}')))
    True

    Multiple values, no formats (can optionally set the delimiter at
    initialization, or later with the `.delim` attribute):

    >>> print_param(Param((3.14159, 6.28319), delim='; '))
    [3.14159, 6.28319] [None, None] 3.14159; 6.28319

    Multiple values with formats:

    >>> x_list, fmt_list = (3.14159, 6.28319), ('{:.2f}', '{:.3f}')
    >>> print_param(Param(x_list, fmt=fmt_list))
    [3.14159, 6.28319] ('{:.2f}', '{:.3f}') 3.14,6.283
    >>> print_param(Param(zip(x_list, fmt_list)))  # same result
    [3.14159, 6.28319] ('{:.2f}', '{:.3f}') 3.14,6.283

    Not all values require formats:

    >>> p.fmt
    '{:.2f}'
    >>> p.val = [x, (2*x, '{:.1f}')]  # Only format the 2nd number
    >>> p.fmt  # `.fmt` is automatically updated with `.val`!
    [None, '{:.1f}']
    >>> p.delim = ' , '
    >>> str(p)
    '3.14159 , 6.3'

    Values and formats can be indexed. Assignment for indexed values breaks
    automatic format updating, however. Also, an indexed value *should not*
    be assigned a value-format pair!

    >>> p.val[1] = 1
    >>> print_param(p)  # `.fmt` is not automatically updated in this case!
    [3.14159, 1] [None, '{:.1f}'] 3.14159 , 1.0
    >>> p.fmt[1] = '{:d}'  # `.fmt` must be updated manually
    >>> str(p)
    '3.14159 , 1'
    >>> p.val[1] = (x, '{:.2f}')  # Don't do this!!!
    >>> str(p)
    ValueError ...

    """

    def __init__(self, val, fmt=None, delim=None):
        fmt0 = fmt
        val_list, fmt_list = get_vals_fmts(val)
        if not val_list:
            val, fmt = None, None
        elif len(val_list) == 1:
            val, fmt = val_list[0], fmt_list[0]
        else:
            val, fmt = val_list, fmt_list
        fmt = fmt if fmt0 is None else fmt0

        self._val = val
        self.fmt = fmt

        if delim is None:
            delim = ','
        self.delim = delim

    def __str__(self):
        if not islistlike(self._val):
            val_list, fmt_list = [self._val], [self._fmt]
        else:
            val_list, fmt_list = self._val, self._fmt

        valstr_list = [str(val) if fmt is None else fmt.format(val)
                       for val, fmt in zip(val_list, fmt_list)]

        return self.delim.join(valstr_list)

    def __repr__(self):
        return str(self.val)

    @property
    def val(self):
        return self._val

    @val.setter
    def val(self, val):
        val_list, fmt_list = get_vals_fmts(val)
        if not val_list:
            val, fmt = None, None
        elif len(val_list) == 1:
            val, fmt = val_list[0], fmt_list[0]
        else:
            val, fmt = val_list, fmt_list
        self._val = val
        self._fmt = fmt

    @property
    def fmt(self):
        return self._fmt

    @fmt.setter
    def fmt(self, fmt):
        if not islistlike(fmt) and islistlike(self._val):
            fmt = [fmt] * len(self._val)
        self._fmt = fmt


def isstring(obj):
    """True if the object is a string."""
    return isinstance(obj, basestring)


def isfmtstr(obj):
    """True if obj looks like a format string."""
    return (isstring(obj) and obj.startswith('{') and obj.endswith('}')
            and ':' in obj)


def islistlike(obj):
    """True if the object is iterable like a list and is *not* a string."""
    return ((hasattr(obj, '__iter__') or hasattr(obj, '__getitem__')) and
            not isstring(obj))


def get_vals_fmts(val):
    """Given a given value, identify the form and return a list of values
    and format strings.

    Parameters
    ----------
    val : None, bool, int, float, str, list, or tuple
        Valid forms of `val` are,

        - x
        - (x, fmt)
        - (x1, x2, ...)
        - [(x1, fmt1), (x2, fmt2), ...]

        where `x` is None, bool, int, float, or str. `fmt` is a format
        string (starts with '{', ends with '}', and contains ':').

    Returns
    -------
    val_list, fmt_list : list
        For the four cases above, the returned lists are,

        - [x], [None]
        - [x], [fmt]
        - [x1, x2, ...], [None, None, ...]
        - [x1, x2, ...], [fmt1, fmt2, ...]

        `val_list` is never empty, and `fmt_list` is always the same length
        as `val_list`.

    """
    val_list, fmt_list = [], []
    val0 = val
    while val0:
        if islistlike(val0):
            if len(val0) == 2 and isfmtstr(val0[1]):  # (val, fmt)
                val, fmt = val0
                val_list.append(val)
                fmt_list.append(fmt)
                break

            else:  # (..., val_i, ...) or [..., (val_i, fmt_i), ...]
                val = val0[0]
                if islistlike(val):  # (val_i, fmt_i)
                    val, fmt = val
                    val_list.append(val)
                    fmt_list.append(fmt)
                else:  # val_i; no format
                    val_list.append(val)
                    fmt_list.append(None)

                if len(val0) == 1:
                    break
                else:
                    val0 = val0[1:]

        else:  # val; no format
            val_list.append(val0)
            fmt_list.append(None)
            break

    else:
        if val0 in [None, False]:
            val_list.append(val0)
            fmt_list.append(None)

    return val_list, fmt_list


# function to process large hybridMC output into separate .sfh or .zcb files.

# search stuff?
